<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithm Visualizer</title>
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        
        body {
            font-family: 'Inter', sans-serif;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #4a5568; /* gray-700 */
            border-radius: 5px;
            outline: none;
            opacity: 0.9;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }
        input[type=range]:hover {
            opacity: 1;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #6366f1; /* indigo-500 */
            border-radius: 50%;
            cursor: pointer;
        }
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #6366f1; /* indigo-500 */
            border-radius: 50%;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col items-center p-4">

    <!-- Header -->
    <h1 class="text-3xl md:text-4xl font-bold text-center text-indigo-400 mt-4 mb-6">
        Sorting Algorithm Visualizer
    </h1>

    <!-- Controls -->
    <div id="controls-container" class="w-full max-w-6xl bg-gray-800 p-4 rounded-lg shadow-xl mb-6 flex flex-col gap-4">
        
        <!-- Top Row: Array Generation & Slider -->
        <div class="flex flex-col md:flex-row gap-4 items-center justify-between">
            <!-- NEW Left Side: Generation, Size, & Speed -->
            <div class="flex flex-col sm:flex-row gap-4 items-center w-full md:w-auto">
                <button id="generate-btn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-200 w-full sm:w-auto">
                    Generate New Array
                </button>
                
                <div class="flex flex-col items-center w-full sm:w-auto md:min-w-[150px]">
                    <label for="size-slider" class="block text-sm font-medium text-gray-300 mb-1">
                        Size
                    </label>
                    <input id="size-slider" type="range" min="2" max="200" value="50" class="w-full">
                    <span id="size-label" class="text-xs text-gray-400 mt-1">Size: 50</span>
                </div>

                <!-- NEW: Speed Slider -->
                <div class="flex flex-col items-center w-full sm:w-auto md:min-w-[150px]">
                    <label for="speed-slider" class="block text-sm font-medium text-gray-300 mb-1">
                        Speed
                    </label>
                    <input id="speed-slider" type="range" min="1" max="200" value="100" class="w-full">
                    <span id="speed-label" class="text-xs text-gray-400 mt-1">Speed: 100</span>
                </div>
            </div>

            <!-- NEW Right Side: Custom Plot -->
            <div id="custom-input-container" class="flex items-center gap-2 w-full md:w-auto">
                <input id="custom-array-input" type="text" placeholder="e.g., 5,3,8,1" class="bg-gray-700 text-white p-2 rounded-lg flex-1 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                <button id="plot-btn" class="bg-emerald-500 hover:bg-emerald-600 text-white font-semibold py-2 px-3 rounded-lg shadow transition duration-200">
                    Plot
                </button>
            </div>
        </div>

        <!-- Divider --> 
        <hr class="border-gray-700">

        <!-- Bottom Row: Sort Buttons -->
        <div class="flex flex-wrap gap-2 justify-center">
            <button id="bubble-sort-btn" class="sort-btn bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded-lg shadow transition duration-200">
                Bubble Sort
            </button>
            <button id="selection-sort-btn" class="sort-btn bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded-lg shadow transition duration-200">
                Selection Sort
            </button>
            <button id="insertion-sort-btn" class="sort-btn bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded-lg shadow transition duration-200">
                Insertion Sort
            </button>
            <button id="quick-sort-btn" class="sort-btn bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded-lg shadow transition duration-200">
                Quick Sort
            </button>
            <button id="merge-sort-btn" class="sort-btn bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded-lg shadow transition duration-200">
                Merge Sort
            </button>
            
            <!-- Stop Button (hidden by default) -->
            <button id="stop-btn" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-200" style="display: none;">
                Stop Sorting
            </button>
        </div>
    </div>

    <!-- Canvas Container -->
    <div class="w-full max-w-6xl h-[40vh] sm:h-[50vh] md:h-[60vh] bg-gray-800 rounded-lg shadow-xl overflow-hidden">
        <canvas id="visualizer-canvas" class="w-full h-full"></canvas>
    </div>

    <!-- Success Modal (Hidden by default) -->
    <div id="success-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4" style="display: none; z-index: 100;">
        <div class="bg-gray-700 text-white p-6 rounded-lg shadow-2xl w-full max-w-sm text-center">
            <h2 class="text-2xl font-bold text-emerald-400 mb-4">Success!</h2>
            <p id="success-message" class="text-lg mb-4">Sorting complete.</p>
            
            <!-- NEW: Sort Stats Display -->
            <div id="sort-stats" class="text-md text-left text-gray-300 mb-6 bg-gray-800 p-4 rounded-lg">
                <p class="flex justify-between">
                    <span>Swaps:</span>
                    <span id="swap-count" class="font-bold text-emerald-400">0</span>
                </p>
                <p class="flex justify-between mt-2">
                    <span id="pass-label">Passes:</span>
                    <span id="pass-count" class="font-bold text-indigo-400">0</span>
                </p>
            </div>
            
            <button id="modal-close-btn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-6 rounded-lg shadow transition duration-200">
                OK
            </button>
        </div>
    </div>

    <script>
        // === DOM Elements ===
        const canvas = document.getElementById('visualizer-canvas');
        const ctx = canvas.getContext('2d');
        const generateBtn = document.getElementById('generate-btn');
        const bubbleSortBtn = document.getElementById('bubble-sort-btn');
        const selectionSortBtn = document.getElementById('selection-sort-btn');
        const insertionSortBtn = document.getElementById('insertion-sort-btn');
        const quickSortBtn = document.getElementById('quick-sort-btn');
        const mergeSortBtn = document.getElementById('merge-sort-btn');
        const stopBtn = document.getElementById('stop-btn');
        const sizeSlider = document.getElementById('size-slider');
        const sizeLabel = document.getElementById('size-label');
        const speedSlider = document.getElementById('speed-slider');  
        const speedLabel = document.getElementById('speed-label');
        const sortBtns = document.querySelectorAll('.sort-btn');
        const controlsContainer = document.getElementById('controls-container');
        const customInputContainer = document.getElementById('custom-input-container');
        const customArrayInput = document.getElementById('custom-array-input');
        const plotBtn = document.getElementById('plot-btn');

        // New Modal Elements
        const successModal = document.getElementById('success-modal');
        const successMessage = document.getElementById('success-message');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        // NEW: Stats Elements
        const swapCountEl = document.getElementById('swap-count');
        const passCountEl = document.getElementById('pass-count');
        const passLabelEl = document.getElementById('pass-label');

        // === State ===
        let array = [];
        let isSorting = false;
        let isStopping = false;
        let arraySize = 50;
        let delay = 100;

        // === Colors ===
        const COLOR_PRIMARY = '#f8fafc'; // gray-50
        const COLOR_COMPARE = '#f43f5e'; // rose-500
        const COLOR_SWAP = '#34d399';    // emerald-400
        const COLOR_PIVOT = '#eab308';   // yellow-500
        const COLOR_SORTED = '#6366f1';  // indigo-500
        const COLOR_BARNO='#FFFFFF';
        // === Initialization ===
        document.addEventListener('DOMContentLoaded', () => {
            // Set initial canvas size
            resizeCanvas();
            // Add resize listener
            window.addEventListener('resize', () => {
                if (!isSorting) {
                    resizeCanvas();
                    drawArray();
                }
            });
            // Add control listeners
            generateBtn.addEventListener('click', () => {
                if (isSorting) return;
                handleSliderChange(); // Update size/delay from slider
                generateNewArray(); // Generate new array
            });
            sizeSlider.addEventListener('input', () => {
                if (isSorting) return;
                handleSliderChange();
            });
            speedSlider.addEventListener('input', () => { // NEW
                if (isSorting) return;
                handleSpeedSliderChange();
            });
            plotBtn.addEventListener('click', handlePlot);
            stopBtn.addEventListener('click', () => {
                isStopping = true;
                stopBtn.disabled = true;
                stopBtn.textContent = "Stopping...";
            });

            bubbleSortBtn.addEventListener('click', () => startSort(bubbleSort, "Bubble Sort"));
            selectionSortBtn.addEventListener('click', () => startSort(selectionSort, "Selection Sort"));
            insertionSortBtn.addEventListener('click', () => startSort(insertionSort, "Insertion Sort"));
            quickSortBtn.addEventListener('click', () => startSort(quickSortWrapper, "Quick Sort"));
            mergeSortBtn.addEventListener('click', () => startSort(mergeSortWrapper, "Merge Sort"));
            
            // New Modal Listener
            modalCloseBtn.addEventListener('click', () => {
                successModal.style.display = 'none';
            });

            // Initial array generation
            handleSliderChange(); // To set initial size
            handleSpeedSliderChange(); // NEW: To set initial delay
            generateNewArray();
        });

        // === Canvas & Array Functions ===

        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }

        function handleSliderChange() {
            arraySize = parseInt(sizeSlider.value);
            // REMOVED delay calculation from here
            sizeLabel.textContent = `Size: ${arraySize}`;
        }

        // NEW: Function to handle the speed slider
        function handleSpeedSliderChange() {
            let speedValue = parseInt(speedSlider.value);
            let maxDelay = 201; // 201 to make the math clean (201 - 200 = 1ms)
            // Invert the value: High speed slider = low delay
            delay = maxDelay - speedValue;
            speedLabel.textContent = `Speed: ${speedValue}`;
        }

        // *** MODIFIED FUNCTION ***
        function generateNewArray() {
            if (isSorting) return;
            customArrayInput.value = ""; // Clear custom input
            
            // Ensure arraySize is synced with slider before generating
            arraySize = parseInt(sizeSlider.value);
            sizeLabel.textContent = `Size: ${arraySize}`; // Reset label
            
            array = [];
            const maxVal = 100; // We'll generate numbers between 1 and 100
            // Leave a 20px margin at the top for text
            const canvasHeight = canvas.height - 25; 

            for (let i = 0; i < arraySize; i++) {
                const val = Math.floor(Math.random() * maxVal) + 1; // The display value
                array.push({
                    value: val, // The number to display
                    height: (val / maxVal) * canvasHeight + 10, // The scaled height
                    color: COLOR_BARNO
                });
            }
            drawArray();
        }

        // *** MODIFIED FUNCTION ***
        function drawArray() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const barWidth = canvas.width / arraySize;
            const barSpacing = barWidth > 3 ? 1 : 0; // Add spacing if bars are wide
            
            // NEW: Font settings
           
            const fontSize = Math.min(16, Math.max(5, barWidth * 0.9)); 
            ctx.font = `${fontSize}px Inter`;
            ctx.textAlign = 'center';

            for (let i = 0; i < array.length; i++) {
                const bar = array[i];
                ctx.fillStyle = bar.color;
                
                // Draw the bar
                ctx.fillRect(
                    i * barWidth,                   // x
                    canvas.height - bar.height,     // y (use .height)
                    barWidth - barSpacing,          // width
                    bar.height                      // height (use .height)
                );

                // Removed the "if (barWidth > 10)" condition
                // Now text will be drawn for all array sizes.
                
                ctx.fillStyle = COLOR_SWAP; // Set text color to Emerald as requested
                
                ctx.fillText(
                        Math.round(bar.value),          // The text to draw (use .value)
                        i * barWidth + (barWidth / 2),  // x (center of the bar)
                        canvas.height - bar.height - 5  // y (5px above the bar)
                );
            }
        }

        // *** MODIFIED FUNCTION ***
        function handlePlot() {
            if (isSorting) return;
            const inputString = customArrayInput.value;
            if (!inputString) return;

            const newValues = inputString.split(/[\s,]+/) // Split by comma or space
                .map(s => parseFloat(s.trim()))
                .filter(n => !isNaN(n) && n > 0); // Filter out invalid numbers and non-positives

            if (newValues.length < 2) {
                console.warn("Please enter at least 2 valid, positive numbers.");
                customArrayInput.value = "Enter at least 2 valid numbers.";
                return;
            }

            const maxVal = Math.max(...newValues);
            const canvasHeight = canvas.height - 20; // Leave margin for text

            array = newValues.map(num => ({
                value: num, // The user's number
                height: (num / maxVal) * canvasHeight + 10, // Scale to fit canvas
                color: COLOR_BARNO 
            }));

            arraySize = array.length;
            
            // Manually update slider and related values
            let maxDelay = 400;
            let minDelay = 1;
            // REMOVED all delay calculations from this function
            
            sizeLabel.textContent = `Size: ${arraySize} (Custom)`; 
            
            drawArray();
        }

        // === Sorting Utilities ===

        function showSortSuccessMessage(algorithmName, stats) {
            successMessage.textContent = `Sorted successfully using ${algorithmName}!`;
            
            swapCountEl.textContent = stats.swaps.toLocaleString();
            passCountEl.textContent = stats.passes.toLocaleString();

            const passLabelMap = {
                "Quick Sort": "Partitions",
                "Merge Sort": "Merges",
                "default": "Passes"
            };
            passLabelEl.textContent = passLabelMap[algorithmName] || passLabelMap["default"];

            successModal.style.display = 'flex';
        }

        async function startSort(sortFunction, algorithmName) {
            if (isSorting) return;
            isSorting = true;
            isStopping = false;
            toggleControls(false);

            try {
                const stats = await sortFunction();
                if (!isStopping) { 
                    await finishSortAnimation();
                    showSortSuccessMessage(algorithmName, stats);
                }
            } catch (error) {
                if (error.message !== "SortCanceled") {
                    console.error("Sorting error:", error);
                }
            } finally {
                isSorting = false;
                toggleControls(true);
                
                if (isStopping) {
                    isStopping = false;
                    generateNewArray(); // Reset array
                }
            }
        }

        function toggleControls(enabled) {
            generateBtn.disabled = !enabled;
            sizeSlider.disabled = !enabled;
            speedSlider.disabled = !enabled; 
            plotBtn.disabled = !enabled;
            customArrayInput.disabled = !enabled;

            sortBtns.forEach(btn => {
                btn.disabled = !enabled;
                btn.style.display = enabled ? 'inline-block' : 'none';
            });
            
            stopBtn.style.display = enabled ? 'none' : 'inline-block';
            stopBtn.disabled = false;
            stopBtn.textContent = "Stop Sorting";
            
            controlsContainer.style.opacity = enabled ? '1' : '0.7';
        }

        async function checkStop() {
            if (isStopping) {
                throw new Error("SortCanceled");
            }
            return new Promise(resolve => setTimeout(resolve, delay));
        }

        function swap(i, j) {
            [array[i], array[j]] = [array[j], array[i]];
        }

        async function finishSortAnimation() {
            for (let i = 0; i < array.length; i++) {
                if (isStopping) return;
                array[i].color = COLOR_SORTED;
                if(i % Math.floor(array.length / 50) === 0 || array.length < 50) {
                   await checkStop();
                   drawArray();
                }
            }
            await new Promise(r => setTimeout(r, 500)); // Wait half a second

            // Reset colors
            for (let i = 0; i < array.length; i++) {
                array[i].color = COLOR_BARNO; 
            }
            drawArray();
        }

        // === Sorting Algorithms ===

        // --- 1. Bubble Sort ---
        
        async function bubbleSort() {
            let stats = { swaps: 0, passes: 0 };
            let n = array.length;
            let swapped;
            do {
                stats.passes++;
                swapped = false;
                for (let i = 0; i < n - 1; i++) {
                    await checkStop();
                    array[i].color = COLOR_COMPARE;
                    array[i + 1].color = COLOR_COMPARE;
                    drawArray();
                    await checkStop();

                    if (array[i].height > array[i + 1].height) { 
                        array[i].color = COLOR_SWAP;
                        array[i + 1].color = COLOR_SWAP;
                        drawArray();
                        await checkStop();
                        
                        swap(i, i + 1);
                        stats.swaps++;
                        swapped = true;

                        drawArray();
                        await checkStop();
                    }

                    array[i].color = COLOR_BARNO; 
                    array[i + 1].color = COLOR_BARNO; 
                }
                array[n - 1].color = COLOR_SORTED;
                n--;
            } while (swapped);

            for (let i = 0; i < n; i++) {
                array[i].color = COLOR_SORTED;
            }
            drawArray();
            return stats;
        }

        // --- 2. Selection Sort ---
        
        async function selectionSort() {
            let stats = { swaps: 0, passes: 0 };
            let n = array.length;

            for (let i = 0; i < n - 1; i++) {
                stats.passes++;
                let min_idx = i;
                array[min_idx].color = COLOR_PIVOT;
                drawArray();
                
                for (let j = i + 1; j < n; j++) {
                    array[j].color = COLOR_COMPARE;
                    drawArray();
                    await checkStop();

                    if (array[j].height < array[min_idx].height) { 
                        array[min_idx].color = COLOR_BARNO; 
                        min_idx = j;
                        array[min_idx].color = COLOR_PIVOT;
                    }
                    drawArray();
                    if(j !== min_idx) array[j].color = COLOR_BARNO; 
                }

                array[i].color = COLOR_SWAP;
                array[min_idx].color = COLOR_SWAP;
                drawArray();
                await checkStop();

                if (min_idx !== i) {
                    swap(min_idx, i);
                    stats.swaps++;
                }

                array[min_idx].color = COLOR_BARNO; 
                array[i].color = COLOR_SORTED;
                drawArray();
                await checkStop();
            }
            array[n - 1].color = COLOR_SORTED;
            drawArray();
            return stats;
        }

        // --- 3. Insertion Sort ---
        
        async function insertionSort() {
            let stats = { swaps: 0, passes: 0 };
            let n = array.length;
            array[0].color = COLOR_SORTED;

            for (let i = 1; i < n; i++) {
                stats.passes++;
                let key = array[i].height; 
                let keyObj = array[i];
                let j = i - 1;

                keyObj.color = COLOR_PIVOT;
                drawArray();
                await checkStop();

                while (j >= 0 && array[j].height > key) { 
                    array[j].color = COLOR_COMPARE;
                    drawArray();
                    await checkStop();

                    array[j + 1] = array[j];
                    stats.swaps++;
                    array[j + 1].color = COLOR_SORTED;
                    array[j] = keyObj;
                    array[j].color = COLOR_PIVOT;

                    drawArray();
                    await checkStop();
                    
                    array[j + 1].color = COLOR_SORTED; 
                    j = j - 1;
                }
                array[j + 1] = keyObj;
                
                for(let k = 0; k <= i; k++) {
                    array[k].color = COLOR_SORTED;
                }
                drawArray();
                await checkStop();
            }
            return stats;
        }


        // --- 4. Quick Sort ---
        async function quickSortWrapper() {
            let stats = { swaps: 0, passes: 0 };
            await quickSort(0, array.length - 1, stats);
            return stats;
        }

        async function quickSort(low, high, stats) {
            if (low < high) {
                stats.passes++;
                let pi = await partition(low, high, stats);
                
                await quickSort(low, pi - 1, stats);
                await quickSort(pi + 1, high, stats);
            }
            if (low >= 0 && low < array.length) array[low].color = COLOR_SORTED;
            if (high >= 0 && high < array.length) array[high].color = COLOR_SORTED;
        }

        // *** MODIFIED: Compares .height ***
        async function partition(low, high, stats) {
            let pivot = array[high].height; 
            array[high].color = COLOR_PIVOT;
            let i = (low - 1);

            for (let j = low; j < high; j++) {
                if (i >= low) array[i].color = COLOR_SWAP;
                array[j].color = COLOR_COMPARE;
                drawArray();
                await checkStop();

                if (array[j].height < pivot) { 
                    i++;
                    
                    if (i !== j) {
                        array[i].color = COLOR_SWAP;
                        array[j].color = COLOR_SWAP;
                        drawArray();
                        await checkStop();

                        swap(i, j);
                        stats.swaps++;
                    }
                }
                
                if (i >= low) array[i].color = COLOR_BARNO; 
                array[j].color = COLOR_BARNO; 
            }

            array[high].color = COLOR_SWAP;
            if(i + 1 < array.length) array[i + 1].color = COLOR_SWAP;
            drawArray();
            await checkStop();
            
            if (i + 1 !== high) {
                swap(i + 1, high);
                stats.swaps++;
            }
            
            if(i + 1 < array.length) array[i + 1].color = COLOR_SORTED; // Pivot is sorted
            array[high].color = COLOR_BARNO; 
            drawArray();
            await checkStop();

            return i + 1;
        }

        // --- 5. Merge Sort ---
       
        async function mergeSortWrapper() {
            let stats = { swaps: 0, passes: 0 };
            // Create a copy of the array *of objects*
            let values = [...array]; 
            await mergeSort(values, 0, array.length - 1, stats);
            return stats;
        }
        
        async function mergeSort(values, l, r, stats) {
            if (l >= r) {
                return;
            }
            let m = l + Math.floor((r - l) / 2);
            await mergeSort(values, l, m, stats);
            await mergeSort(values, m + 1, r, stats);
            await merge(values, l, m, r, stats);
        }

        
        async function merge(values, l, m, r, stats) {
            stats.passes++;
            let n1 = m - l + 1;
            let n2 = r - m;

            // Create temp arrays
            let L = new Array(n1);
            let R = new Array(n2);

            
            for (let i = 0; i < n1; i++) {
                L[i] = values[l + i];
            }
            for (let j = 0; j < n2; j++) {
                R[j] = values[m + 1 + j];
            }

            let i = 0;
            let j = 0;
            let k = l;

            while (i < n1 && j < n2) {
                array[l + i].color = COLOR_COMPARE;
                array[m + 1 + j].color = COLOR_COMPARE;
                drawArray();
                await checkStop();

                
                if (L[i].height <= R[j].height) { 
                    values[k] = L[i];
                    array[k] = L[i]; // Copy object
                    array[k].color = COLOR_SWAP;
                    stats.swaps++;
                    i++;
                } else {
                    values[k] = R[j];
                    array[k] = R[j]; // Copy object
                    array[k].color = COLOR_SWAP; 
                    stats.swaps++;
                    j++;
                }
                

                drawArray(); // Draw the swap
                await checkStop();
                array[k].color = COLOR_BARNO; 
                k++;
            }

            // Copy remaining *objects* of L[]
            while (i < n1) {
                values[k] = L[i];
                array[k] = L[i]; 
                array[k].color = COLOR_SWAP;
                stats.swaps++;
                drawArray();
                await checkStop();
                array[k].color = COLOR_BARNO; 
                i++;
                k++;
            }

            // Copy remaining *objects* of R[]
            while (j < n2) {
                values[k] = R[j];
                array[k] = R[j]; // Copy object
                array[k].color = COLOR_SWAP;
                stats.swaps++;
                drawArray();
                await checkStop();
                array[k].color = COLOR_BARNO;
                j++;
                k++;
            }
            
            for(let c = l; c <= r; c++) {
                array[c].color = COLOR_SORTED;
            }
            drawArray();
            await checkStop();
        }

    </script>
</body>
</html>